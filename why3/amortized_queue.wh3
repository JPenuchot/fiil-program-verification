theory Queue
  (* use why3.BuiltIn.BuiltIn *)
  
  (* use why3.Bool.Bool *)
  
  (* use why3.Unit.Unit *)
  
  predicate _TO_BE_COMPLETED
  
  (* use int.Int *)
  
  (* use list.ListRich *)
  
  goal VC queue :
    (length (Nil: list 'a) - length (Nil: list 'a)) = 0 /\ 0 >= 0
  
  type queue 'a
  
  function front (queue 'a) : list 'a
  
  function back (queue 'a) : list 'a
  
  function delta (queue 'a) : int
  
  axiom queue'invariant :
    forall self:queue 'a [delta self| back self| front self].
     (length (front self) - length (back self)) = delta self /\
     delta self >= 0
  
  function view (q:queue 'a) : list 'a = front q ++ reverse (back q)
  
  goal VC empty :
    let o = (Nil: list 'xi) in
    let o1 = (Nil: list 'xi) in
    ((length o1 - length o) = 0 /\ 0 >= 0) /\
    (forall result:queue 'xi.
      front result = o1 /\ back result = o /\ delta result = 0 ->
      view result = (Nil: list 'xi))
  
  goal VC head :
    forall q:queue 'a.
     not view q = (Nil: list 'a) ->
     (let o = front q in
      match o with
      | Nil -> false
      | Cons h _ -> true
      end /\
      (forall result:'a.
        match o with
        | Nil -> false
        | Cons h _ -> result = h
        end -> match view q with
        | Cons h tl -> result = h
        | Nil -> false
        end))
  
  goal VC update :
    forall f:list 'a, b:list 'a, old_d:int.
     ((length f - length b) + 1) = old_d /\ old_d >= 0 ->
     (let o = length f + length b in
      let o1 = (Nil: list 'a) in
      let o2 = f ++ reverse b in
      ((length o2 - length o1) = o /\ o >= 0) /\
      (forall result:queue 'a.
        front result = o2 /\ back result = o1 /\ delta result = o ->
        view result = (f ++ reverse b)))
  
  goal VC tail :
    forall q:queue 'a.
     not view q = (Nil: list 'a) ->
     (let o = front q in
      match o with
      | Nil -> false
      | Cons _ t ->
          let o1 = delta q in
          ((length t - length (back q)) + 1) = o1 /\ o1 >= 0
      end /\
      (forall result:queue 'a.
        match o with
        | Nil -> false
        | Cons _ t -> view result = (t ++ reverse (back q))
        end ->
        match view q with
        | Cons h tl -> view result = tl
        | _ -> false
        end))
  
  goal VC enqueue :
    forall q:queue 'a, x:'a.
     not view q = (Nil: list 'a) ->
     (let o = delta q in
      let o1 = Cons x (back q) in
      let o2 = front q in
      (((length o2 - length o1) + 1) = o /\ o >= 0) /\
      (forall result:queue 'a.
        view result = (o2 ++ reverse o1) ->
        view result = (view q ++ Cons x (Nil: list 'a))))
end

